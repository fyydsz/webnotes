"use client";
/* eslint-disable @typescript-eslint/no-explicit-any */

import React, { useMemo, useEffect } from "react";
import { usePathname, useSearchParams, useRouter } from "next/navigation";
import type { ReactNode } from "react";
import { Layout } from "nextra-theme-docs";
import { LastUpdated } from "./last-updated";

/**
 * Nextra Layout wrapper (client-side).
 *
 * Responsibilities:
 * - For /docs routes:
 *   * Remove the default "Daftar Semua Matkul" group (separator `--` and `mata_kuliah`) so
 *     the docs top-level navigation stays focused on main pages like Home and
 *     Documentation (we don't want the complete course tree at the docs root).
 * - For /mata_kuliah/* routes:
 *   * Promote the `mata_kuliah` children (individual courses) to top-level so
 *     the sidebar directly lists each course.
 *   * Optionally filter course pages by `?prodi=...` query param (only pages
 *     whose frontmatter `prodi` array includes the value are kept).
 *
 * Implementation notes:
 * - We intentionally keep `route` values path-only (no query params) because
 *   adding query strings to `route` breaks Nextra's active-link and pagination
 *   detection. Instead, we preserve query params at navigation time by:
 *   1) patching rendered anchor hrefs (so open-in-new-tab / middle-click work),
 *   2) adding a capture-phase click interceptor (so client pushes include the param).
 */

interface NextraLayoutWrapperProps {
  pageMap: unknown;
  navbar?: ReactNode;
  banner?: ReactNode;
  docsRepositoryBase?: string;
  copyPageButton?: boolean;
  sidebar?: unknown;
  feedback?: unknown;
  editLink?: string | ReactNode;
  toc?: unknown;
  children?: ReactNode;
}

function isRecord(x: unknown): x is Record<string, unknown> {
  return typeof x === "object" && x !== null;
}

/**
 * Extract the `prodi` frontmatter from a page/node.
 *
 * Nextra's pageMap nodes can expose frontmatter in different keys depending
 * on build or how the page was authored. This helper checks several common
 * locations and returns a normalized array of `prodi` strings when found:
 * - node.prodi
 * - node.data?.prodi
 * - node.meta?.prodi
 * - node.frontmatter?.prodi or node.frontMatter?.prodi
 * - node.props?.meta?.prodi
 *
 * Returns an array of strings if present, otherwise `undefined`.
 */
function extractProdi(node: unknown): string[] | undefined {
  if (!isRecord(node)) return undefined;
  const n = node as Record<string, unknown> & { [k: string]: any };

  const candidates = [
    n.prodi,
    (n.data as any)?.prodi,
    (n.meta as any)?.prodi,
    (n.frontmatter as any)?.prodi,
    (n.frontMatter as any)?.prodi,
    (n.props as any)?.meta?.prodi,
    (n.props as any)?.frontmatter?.prodi,
  ];

  for (const cand of candidates) {
    if (!cand) continue;
    if (Array.isArray(cand)) {
      return cand.map(String);
    }
    if (typeof cand === "string") {
      return [cand];
    }
  }

  return undefined;
}

function nodeHasProdi(node: unknown, prodi?: string): boolean {
  if (!prodi) return false;
  const arr = extractProdi(node);
  return Array.isArray(arr) ? arr.includes(prodi) : false;
}

// route-append helper removed — we keep original `route` so Nextra's active/pagination logic remains stable

// Walk the pageMap and append `?key=value` to all discovered `route` fields.
// This ensures links generated by Nextra (sidebar, pagination, etc.) preserve
// the active `prodi` query parameter.
// appendQueryToPageMapRoutes removed — prefer preserving `route` values and handling `prodi` during navigation

/**
 * Humanize a prodi slug into a readable label.
 *
 * Examples:
 * - "sistem_informasi" -> "Sistem Informasi"
 * - "teknik-informatika" -> "Teknik Informatika"
 */
function humanizeProdiSlug(slug: string | undefined): string {
  if (!slug) return "";
  return slug
    .replace(/[-_]+/g, " ")
    .split(" ")
    .map((w) => (w.length > 0 ? w[0].toUpperCase() + w.slice(1) : ""))
    .join(" ");
}

/**
 * filterPageMapForDocs:
 *
 * This prepares a pageMap for the `/docs` overview page. It:
 * - Removes the `--` separator used for the 'Daftar Semua Matkul' group, and
 * - Removes the `mata_kuliah` entry entirely from the top-level `data` and
 *   drops its node so the docs top navigation does not show a "Mata Kuliah"
 *   grouping. The intent is to keep the docs root navigation simple and focus
 *   on general docs pages (Home, Documentation) rather than the full course tree.
 *
 * Example (after this filter runs on `/docs`):
 * - data
 *   - index: { type: 'page', title: 'Home' }
 *   - docs: { type: 'page', title: 'Documentation' }
 * - docs (node)
 *   - name: docs
 *   - route: /docs
 *   - title: Documentation
 *
 * Returns a cloned & adjusted pageMap array.
 */
function filterPageMapForDocs(original: unknown): unknown[] {
  if (!Array.isArray(original)) return [];

  // Deep clone when possible
  let cloned: unknown;
  try {
    cloned = JSON.parse(JSON.stringify(original));
  } catch {
    cloned = (original as unknown[]).slice();
  }

  const arr = cloned as unknown[];

  if (
    Array.isArray(arr) &&
    arr.length > 0 &&
    typeof arr[0] === "object" &&
    "data" in (arr[0] as Record<string, unknown>)
  ) {
    const first = arr[0] as Record<string, unknown>;
    const data = { ...(first.data as Record<string, unknown>) };

    if ("--" in data) delete data["--"];

    // remove mata_kuliah from top-level data so it won't appear in /docs top nav
    if ("mata_kuliah" in data) delete data["mata_kuliah"];

    arr[0] = { ...first, data } as unknown;
  }

  const rest = arr
    .slice(1)
    .map((node: unknown) => {
      if (!isRecord(node)) return node;
      const nameVal = node.name;
      if (typeof nameVal !== "string") return node;

      if (nameVal === "--") return null; // drop separator

      if (nameVal === "mata_kuliah") {
        // drop mata_kuliah entirely in /docs
        return null;
      }

      return node;
    })
    .filter((n: unknown) => n !== null);

  return arr.length > 0 ? [arr[0], ...rest] : rest;
}

/**
 * filterPageMapFlattenMataKuliahChildren:
 *
 * For routes under `/mata_kuliah/*` we promote the `mata_kuliah` node's children
 * (each course) to top-level so the sidebar lists courses directly.
 *
 * Optional `prodiFilter`:
 * - If provided (string), we recursively prune course children so only pages
 *   whose frontmatter `prodi` array includes `prodiFilter` are kept.
 * - Important: the `prodi` filter is applied only inside promoted course nodes
 *   (i.e. courses and their pages). Other top-level pages (Home, Documentation)
 *   are not removed by `prodi` filtering.
 *
 * Example (after flattening, before prodi filter):
 * - data
 *   - index: { type: 'page', title: 'Home' }
 *   - docs: { type: 'page', title: 'Documentation' }
 * - nodes
 *   - { name: 'bahasa_indonesia', route: '/mata_kuliah/bahasa_indonesia', children: ['diksi', 'kalimat', ...] }
 *   - { name: 'dasar_pemrograman_python', route: '/mata_kuliah/dasar_pemrograman_python', children: ['install_python', 'sintaks_dasar', ...] }
 *
 * Example (when visiting `/mata_kuliah/dasar_pemrograman_python?prodi=sistem_informasi`):
 * - sidebar for 'dasar_pemrograman_python' will only include pages whose MDX frontmatter contains:
 *   prodi: [ 'sistem_informasi', ... ]
 */
function filterPageMapFlattenMataKuliahChildren(
  original: unknown,
  prodiFilter?: string,
): unknown[] {
  if (!Array.isArray(original)) return [];

  let cloned: unknown;
  try {
    cloned = JSON.parse(JSON.stringify(original));
  } catch {
    cloned = (original as unknown[]).slice();
  }

  const arr = cloned as unknown[];
  if (arr.length === 0) return [];

  // Capture mata_kuliah data (if present) before we delete it.
  let mataData: Record<string, unknown> | undefined;
  if (isRecord(arr[0]) && isRecord(arr[0].data)) {
    const first = arr[0] as Record<string, unknown>;
    const data = { ...(first.data as Record<string, unknown>) };
    if ("mata_kuliah" in data && isRecord(data["mata_kuliah"])) {
      mataData = data["mata_kuliah"] as Record<string, unknown>;
    }
    if ("mata_kuliah" in data) delete data["mata_kuliah"];
    arr[0] = { ...first, data } as unknown;
  }

  const rest: unknown[] = [];
  for (const node of arr.slice(1)) {
    if (!isRecord(node)) {
      rest.push(node);
      continue;
    }
    const nameVal = node.name;
    if (typeof nameVal !== "string") {
      rest.push(node);
      continue;
    }

    if (nameVal === "mata_kuliah") {
      const children = node.children;
      if (Array.isArray(children) && children.length > 0) {
        // promote children to top-level
        rest.push(...children);
      }
      continue; // skip parent
    }

    rest.push(node);
  }

  // If no prodi filter requested, return as-is
  if (!prodiFilter) {
    return [arr[0], ...rest];
  }

  // When a prodi filter is active, update any 'Daftar Semua Matkul' separators to show the
  // current prodi (e.g. "Matkul Sistem Informasi") to make the context obvious
  // in the sidebar.
  (function updateDaftarMatkulSeparators() {
    const human = humanizeProdiSlug(prodiFilter);

    // Update top-level `data["--"]` entry if present and labeled "Daftar Semua Matkul"
    if (
      isRecord(arr[0]) &&
      isRecord((arr[0] as Record<string, unknown>).data)
    ) {
      const first = arr[0] as Record<string, unknown>;
      const data = { ...(first.data as Record<string, unknown>) };
      if ("--" in data && isRecord(data["--"])) {
        const sep = { ...(data["--"] as Record<string, unknown>) };
        if (
          typeof sep.title === "string" &&
          sep.title === "Daftar Semua Matkul"
        ) {
          sep.title = `Matkul ${human}`;
          data["--"] = sep;
          arr[0] = { ...first, data } as unknown;
        }
      }
    }

    // Also patch any separator nodes in the flattened list
    for (let i = 0; i < rest.length; i++) {
      const node = rest[i];
      if (!isRecord(node)) continue;
      if (
        (node as any).name === "--" &&
        (node as any).title === "Daftar Semua Matkul"
      ) {
        rest[i] = {
          ...(node as Record<string, unknown>),
          title: `Matkul ${human}`,
        } as unknown;
      }
    }
  })();

  // Otherwise, recursively filter each promoted course and its children
  const filteredRest: unknown[] = [];

  function recursivelyFilterNode(node: unknown): unknown | null {
    // Handle string children by consulting mataData mapping if available
    if (typeof node === "string") {
      if (mataData && node in mataData) {
        const meta = mataData[node];
        if (isRecord(meta) && "prodi" in meta) {
          const p = (meta as Record<string, unknown>)["prodi"];
          if (Array.isArray(p)) {
            return (p as unknown[]).includes(prodiFilter) ? node : null;
          }
          if (typeof p === "string") {
            return p === prodiFilter ? node : null;
          }
        }
      }
      return null;
    }

    if (!isRecord(node)) return node;

    const copy = { ...(node as Record<string, unknown>) } as Record<
      string,
      unknown
    >;

    // Recurse into children if present
    if (Array.isArray(copy.children) && copy.children.length > 0) {
      const newChildren = (copy.children as unknown[])
        .map((c) => recursivelyFilterNode(c))
        .filter((c) => c !== null);
      copy.children = newChildren;
    }

    // Keep node if it has children remaining
    if (
      Array.isArray(copy.children) &&
      (copy.children as unknown[]).length > 0
    ) {
      return copy;
    }

    // Otherwise, keep node only if it itself matches the prodi filter
    if (nodeHasProdi(copy, prodiFilter)) {
      return copy;
    }

    // No match
    return null;
  }

  for (const node of rest) {
    // Keep any non-record (primitive/string) nodes as-is
    if (!isRecord(node)) {
      filteredRest.push(node);
      continue;
    }

    // Only apply the `prodi` recursive filtering to nodes that are actual mata_kuliah
    // course entries (their routes start with `/mata_kuliah`). For other top-level
    // nodes like `index` or `docs`, keep them unchanged so top-level navigation
    // (Home / Documentation) remains visible even when ?prodi=... is active.
    const nodeRoute = (node as Record<string, unknown>).route;
    if (typeof nodeRoute === "string" && nodeRoute.startsWith("/mata_kuliah")) {
      const kept = recursivelyFilterNode(node);
      if (kept !== null) filteredRest.push(kept as unknown);
      continue;
    }

    // Non-mata_kuliah top-level nodes are kept unchanged
    filteredRest.push(node);
  }

  return [arr[0], ...filteredRest];
}

export default function NextraLayoutWrapper(props: NextraLayoutWrapperProps) {
  const {
    pageMap,
    navbar,
    banner,
    docsRepositoryBase,
    copyPageButton,
    sidebar,
    feedback,
    editLink,
    toc,
    children,
  } = props;

  const pathname = usePathname();
  const searchParams = useSearchParams();
  const prodi = searchParams?.get?.("prodi") ?? undefined;
  const router = useRouter();

  const adjustedPageMap = useMemo(() => {
    // If pathname is not yet available on first render, return the original map shape
    if (!pathname) return Array.isArray(pageMap) ? (pageMap as unknown[]) : [];

    // Apply filtering for docs pages
    if (pathname === "/docs" || pathname.startsWith("/docs/")) {
      return filterPageMapForDocs(pageMap);
    }

    // For /mata_kuliah/* routes, flatten the mata_kuliah node's children
    // and optionally filter pages by the `prodi` query parameter.
    if (pathname.startsWith("/mata_kuliah/")) {
      const flattened = filterPageMapFlattenMataKuliahChildren(pageMap, prodi);
      try {
        console.debug("NextraLayoutWrapper - flattened mata_kuliah children:", {
          prodi,
          flattened,
        });
      } catch {
        // swallow any logging errors
      }
      return flattened;
    }

    return Array.isArray(pageMap) ? (pageMap as unknown[]) : [];
  }, [pageMap, pathname, prodi]);

  // finalPageMap removed; prodi preservation is handled via click-interceptor and href patching

  useEffect(() => {
    if (!pathname) return;
    if (pathname === "/docs" || pathname.startsWith("/docs/")) {
      try {
        console.debug(
          "NextraLayoutWrapper - adjusted pageMap for /docs:",
          adjustedPageMap,
        );
      } catch {
        // swallow any logging errors
      }
    } else if (pathname.startsWith("/mata_kuliah/")) {
      try {
        console.debug(
          "NextraLayoutWrapper - flattened mata_kuliah children for:",
          {
            prodi:
              typeof (window as any) !== "undefined"
                ? new URLSearchParams(location.search).get("prodi")
                : undefined,
            adjustedPageMap,
          },
        );
      } catch {
        // swallow errors
      }
    }
  }, [adjustedPageMap, pathname]);

  /**
   * Anchor patching (open-in-new-tab / middle-click support)
   *
   * - We patch anchor hrefs that point to `/mata_kuliah` so users who
   *   middle-click or choose "open in new tab" get the `prodi` query param
   *   when it is active (this helps expected UX when browsing by program).
   * - A MutationObserver ensures anchors added later get patched as well.
   * - As a safety/fallback we also have a click-interceptor (capture-phase)
   *   to guarantee client-side navigations include the query when needed.
   */
  useEffect(() => {
    if (!prodi) return;

    function patchAnchors() {
      try {
        const anchors = Array.from(
          document.querySelectorAll<HTMLAnchorElement>(
            'a[href*="/mata_kuliah"], a[data-preserve-prodi]',
          ),
        );
        for (const a of anchors) {
          let href = a.getAttribute("href") || "";
          // Skip external / mailto / anchors
          if (/^(https?:|mailto:|#)/i.test(href)) continue;

          // If the current href doesn't include `prodi` append it, and ensure
          // the anchor is patched. If it already includes `prodi`, we still
          // attach a click handler below to guarantee client navigation uses
          // the (possibly patched) href instead of an older Link prop value.
          if (!/[?&]prodi=/.test(href)) {
            const [pathAndQuery, hash] = href.split("#");
            const [base, q] = pathAndQuery.split("?");
            const newQuery = q
              ? `${q}&prodi=${encodeURIComponent(prodi as string)}`
              : `prodi=${encodeURIComponent(prodi as string)}`;
            href = `${base}?${newQuery}${hash ? `#${hash}` : ""}`;
            a.setAttribute("href", href);
          }

          // Attach a capture-phase click handler once so client-side navigations
          // (Next.js Link) use the href that includes `prodi`. This prevents the
          // Link component from routing to its original prop value without the query.
          if (!a.dataset.__prodiClickHandlerAttached) {
            a.addEventListener(
              "click",
              (ev: MouseEvent) => {
                // Only handle left clicks without modifiers and if not already prevented.
                if ((ev as any).defaultPrevented) return;
                if ((ev as any).button !== 0) return;
                if (
                  (ev as any).metaKey ||
                  (ev as any).ctrlKey ||
                  (ev as any).shiftKey ||
                  (ev as any).altKey
                )
                  return;

                let url: URL;
                try {
                  // Use the resolved `a.href` (absolute URL resolved by the browser)
                  // so relative hrefs are interpreted relative to the current page
                  // (e.g. `/mata_kuliah/...`) instead of being resolved against the
                  // origin root only. This ensures clicks navigate to the expected
                  // `/mata_kuliah/...` path.
                  url = new URL(a.href);
                } catch {
                  return;
                }

                // Ensure `prodi` present in the navigation target
                if (!url.searchParams.has("prodi")) {
                  url.searchParams.append("prodi", prodi as string);
                }

                // Prevent other handlers (including Link's) and perform client navigation
                ev.preventDefault();
                ev.stopImmediatePropagation();
                router.push(`${url.pathname}${url.search}${url.hash}`);
              },
              true,
            );
            a.dataset.__prodiClickHandlerAttached = "1";
          }
        }
      } catch {
        // ignore errors when DOM shapes are unexpected
      }
    }

    // initial patch
    patchAnchors();

    // observe DOM mutations so anchors added later also get patched
    const observer = new MutationObserver(() => {
      try {
        patchAnchors();
      } catch {
        /* ignore */
      }
    });
    observer.observe(document.body, { childList: true, subtree: true });

    return () => observer.disconnect();
  }, [prodi, adjustedPageMap, pathname, router]);

  /**
   * Click-interceptor (capture-phase)
   *
   * - Runs before other click handlers so we can enforce that client-side
   *   navigations to `/mata_kuliah` include the `prodi` query when the current
   *   page has one active.
   * - Only handles left-clicks without modifier keys; modifier clicks (new tab,
   *   open in background) are left to the user and are covered by href patching.
   */

  useEffect(() => {
    if (!prodi) return;
    const currentProdi = prodi!;
    const onClick = (e: MouseEvent) => {
      if (e.defaultPrevented) return;
      // only left clicks without modifier
      if ((e as any).button !== 0) return;
      if (
        (e as any).metaKey ||
        (e as any).ctrlKey ||
        (e as any).shiftKey ||
        (e as any).altKey
      )
        return;

      const target = e.target as Element | null;
      const anchor =
        target &&
        ((target.closest
          ? (target.closest as any)("a")
          : null) as HTMLAnchorElement | null);
      if (!anchor) return;

      const href = anchor.getAttribute("href");
      if (!href) return;
      // skip external/mailto/hash
      if (/^(https?:|mailto:|#)/i.test(href)) return;
      let url: URL;
      try {
        url = new URL(href, location.origin);
      } catch {
        return;
      }
      if (!url.pathname.startsWith("/mata_kuliah")) return;

      // ensure `prodi` present in the navigation target, then navigate via router
      if (!url.searchParams.has("prodi")) {
        url.searchParams.append("prodi", currentProdi);
      }

      e.preventDefault();
      router.push(`${url.pathname}${url.search}${url.hash}`);
    };

    // run in capture phase so we override other handlers (like Nextra's Link handler)
    document.addEventListener("click", onClick, true);
    return () => document.removeEventListener("click", onClick, true);
  }, [prodi, router, pathname]);

  return (
    <Layout
      pageMap={adjustedPageMap as any}
      navbar={navbar as any}
      banner={banner as any}
      docsRepositoryBase={docsRepositoryBase as any}
      copyPageButton={copyPageButton as any}
      sidebar={sidebar as any}
      feedback={feedback as any}
      editLink={editLink as any}
      lastUpdated={<LastUpdated />}
      toc={toc as any}
    >
      {children}
    </Layout>
  );
}
